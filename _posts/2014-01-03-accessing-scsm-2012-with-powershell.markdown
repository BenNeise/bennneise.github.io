---
layout: post
title: Accessing SCSM 2012 using PowerShell (without SMLets)
date: '2014-01-03 11:48:11'
tags: powershell microsoft-windows
---


![SCSM2012](/assets/SCSM2012.png){: .center-image}

I wanted to use PowerShell to create a simple report of open (active & pending) incidents in System Center Service Manager 2012, but the [only examples](http://www.systemcentercentral.com/scsm-2012-quicktip-retrieving-the-assigned-user-info-for-a-work-item-via-powershell-scsm-scorch-sysctr/) I could find online used the [SMLets](http://smlets.codeplex.com/). Sometimes this wasn't obvious, but soon became apparent when PowerShell choked over CMDLets like **Get-SCSMObject**.

While I'm sure the SMLets are handy for ad-hoc reports by administrators, I wanted the option for my report to be generated by a group of users on their own machines, so I was wary about deploying unnecessary (beta) software to a group of desktops. It was therefore preferable to do this using the [native SCSM 2012 CMDlets](http://technet.microsoft.com/en-us/library/hh305227(v=sc.20).aspx) (which the users already have installed as part of the SCSM 2012 installation).

[Anton Gritsenko](http://blog.scsmsolutions.com/author/freemanru/)ÔÇÿs [mapping of the SMLets to their SCSM 2012 native commands](http://blog.scsmsolutions.com/2012/02/reference-between-smlets-and-scsm-2012-native-cmdlets/) was invaluable in the creation of this.

```powershell
# Import the SCSM Native CMDLets
Import-Module "C:\Program Files\Microsoft System Center 2012\Service Manager\Powershell\System.Center.Service.Manager.psd1"

# Name of your SCSM Server
$strSCSMServer = "YourSCSMServer"

New-SCSMManagementGroupConnection -ComputerName $strSCSMServer

$objRelationshipAssignedToUser = Get-SCSMRelationship -Name "System.WorkItemAssignedToUser"
$objRelationshipAffectedUser = Get-SCSMRelationship -Name "System.WorkItemAffectedUser"

# Get an object containing all open incidents 
$objIncidentsOpen = (Get-SCClassInstance -Class (Get-SCClass -Name "System.WorkItem.Incident")) | Where-Object {
    $_.Status.ToString() -ne "IncidentStatusEnum.Closed" -and $_.Status.ToString() -ne "IncidentStatusEnum.Resolved"
}

# Format the object with calculated properties to display the required information
$objIncidentsOpen | Select-Object `
	Id,
    Title,
    @{Name="Source";Expression={$_.Source.DisplayName}},
    CreatedDate,
    Priority,
    @{Name="Affected User";Expression={$_.GetRelatedObjectsWhereSource($objRelationshipAffectedUser)}},
    @{Name="Status";Expression={$_.Status.DisplayName}},
    @{Name="SupportGroup";Expression={$_.TierQueue.DisplayName}},
    @{Name="Assigned To";Expression={$_.GetRelatedObjectsWhereSource($objRelationshipAssignedToUser)}} 

# End of script
```

This script should work on any machine with PowerShell and SCSM Console installed. As with all PowerShell objects, this can then be output to HTML, CSV etc.

This is the first component of a more involved MI framework I have in mind, and was good practice with the SCSM 2012 API.


